# -*- coding: utf-8 -*-
"""fix Submission Machine Learning Terapan Predictive Revenue Coffee Shop.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r7O01wfnSSdAsz5bhqdc5aLcIdbnzcWA

## Import Library
"""

# Import library yang diperlukan
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import ElasticNet, Ridge
from sklearn.metrics import mean_squared_error, r2_score, accuracy_score, f1_score, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import skew
from sklearn.linear_model import LinearRegression

"""Deskripsi : Mengimpor pustaka untuk manipulasi data (pandas, numpy), preprocessing (StandardScaler, OneHotEncoder), pembuatan model (ElasticNet, LinearRegression), evaluasi model (mean_squared_error, r2_score), dan visualisasi (matplotlib, seaborn). Pustaka ini penting untuk mendukung analisis data dan pembuatan model machine learning.

## Load Dataset
"""

pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)
revenue_df = pd.read_csv('https://raw.githubusercontent.com/Ezraliano/Revenue_Analysis/refs/heads/main/coffee-shop-sales-revenue.csv', delimiter='|')

# Tampilkan 5 baris pertama
print(revenue_df.head().to_markdown(index=False, numalign="left", stralign="left"))

# Tampilkan informasi kolom dan tipe datanya
print(revenue_df.info())

"""Deskripsi : Memuat dataset dari URL publik dalam format CSV menggunakan pandas. Dataset berisi data transaksi kedai kopi, dengan pemisah (delimiter) berupa tanda |. Pengaturan pandas diubah untuk menampilkan semua baris dan kolom tanpa batasan, memudahkan inspeksi data."""

revenue_df.tail()

"""## EDA"""

# Mengecek Tipe Data
revenue_df.dtypes

"""Deskripsi : Memulai Exploratory Data Analysis (EDA) untuk memahami dataset. Memeriksa tipe data setiap kolom menggunakan dtypes untuk memastikan kolom numerik dan kategorikal terdeteksi dengan benar."""

# Menganalisis Distribusi Data
numeric_columns = revenue_df.select_dtypes(include=['float64', 'int64']).columns
skewness = revenue_df[numeric_columns].apply(skew)
print("Skewness untuk setiap kolom numerik:")
print(skewness.to_markdown())

"""Deskripsi : Mengidentifikasi kolom numerik (float64, int64) dan menghitung skewness (kemiringan distribusi) menggunakan scipy.stats.skew. Skewness menunjukkan apakah data simetris atau condong, yang penting untuk menentukan transformasi data jika diperlukan. Hasil ditampilkan dalam format Markdown."""

# Visualisasi distribusi dan skewness
for col in numeric_columns:
    plt.figure(figsize=(8, 4))
    sns.histplot(revenue_df[col], kde=True, bins=30, color='blue')
    plt.title(f'Distribusi {col} (Skewness: {skewness[col]:.2f})')
    plt.xlabel(col)
    plt.ylabel('Frekuensi')
    plt.show()

"""Deskripsi : Membuat histogram dengan Kernel Density Estimation (KDE) untuk setiap kolom numerik. Visualisasi ini menunjukkan distribusi data dan tingkat skewness, membantu mengidentifikasi apakah data perlu ditransformasi (misalnya, log transformation untuk data yang sangat condong)."""

# Mendeteksi missing values
missing_values = revenue_df.isnull().sum()
print("Jumlah missing values untuk setiap kolom:")
print(missing_values.to_markdown())

"""Deskripsi : Memeriksa jumlah nilai yang hilang (missing values) di setiap kolom menggunakan isnull().sum()."""

# Boxplot untuk mendeteksi outlier
for col in numeric_columns:
    plt.figure(figsize=(8, 4))
    sns.boxplot(data=revenue_df, y=col, color='orange')
    plt.title(f'Boxplot {col}')
    plt.ylabel(col)
    plt.show()

"""Deskripsi : Membuat boxplot untuk setiap kolom numerik untuk mendeteksi outlier (nilai ekstrem)."""

# Heatmap korelasi
plt.figure(figsize=(10, 8))
correlation_matrix = revenue_df[numeric_columns].corr()
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Heatmap Korelasi')
plt.show()

"""Deskripsi : Membuat heatmap korelasi untuk kolom numerik menggunakan seaborn. Heatmap menunjukkan hubungan antar variabel numerik (nilai korelasi dari -1 hingga 1)."""

# Fungsi untuk mendeteksi outliers menggunakan IQR
def detect_outliers_iqr(data):
    q1 = data.quantile(0.25)
    q3 = data.quantile(0.75)
    iqr = q3 - q1
    lower_bound = q1 - 1.5 * iqr
    upper_bound = q3 + 1.5 * iqr
    outliers = data[(data < lower_bound) | (data > upper_bound)]
    return outliers, lower_bound, upper_bound

# Deteksi outliers untuk setiap kolom numerik
for col in numeric_columns:
    outliers, lower_bound, upper_bound = detect_outliers_iqr(revenue_df[col])
    print(f"Kolom: {col}")
    print(f"Jumlah outliers: {len(outliers)}")
    print(f"Batas bawah: {lower_bound:.2f}, Batas atas: {upper_bound:.2f}")
    print("Nilai outliers:")
    print(outliers.to_markdown())
    print("\n")

"""Deskripsi : Mendefinisikan fungsi detect_outliers_iqr untuk mendeteksi outlier menggunakan metode Interquartile Range (IQR). Dan Menerapkan fungsi detect_outliers_iqr pada setiap kolom numerik untuk mendeteksi outlier.

## Data Preparation

## Penanganan Skewness unit_price
"""

# Log transformation untuk unit_price
revenue_df['unit_price_log'] = np.log1p(revenue_df['unit_price'])
log_skewness = skew(revenue_df['unit_price_log'])
print(f"Skewness setelah Log Transformation: {log_skewness:.2f}")
plt.figure(figsize=(8, 4))
sns.histplot(revenue_df['unit_price_log'], kde=True, bins=30, color='green')
plt.title(f'Distribusi unit_price setelah Log Transformation (Skewness: {log_skewness:.2f})')
plt.xlabel('unit_price_log')
plt.ylabel('Frekuensi')
plt.show()

"""Deskripsi : Melakukan log transformation pada kolom unit_price menggunakan np.log1p untuk mengurangi skewness (kemiringan distribusi). Skewness setelah transformasi dihitung dan divisualisasikan dengan histogram. Transformasi ini membuat distribusi data lebih mendekati normal, yang dapat meningkatkan performa model regresi.

## Penanganan Outliers dengan Metode IQR
"""

# Hapus outliers berdasarkan IQR
for col in numeric_columns:
    q1 = revenue_df[col].quantile(0.25)
    q3 = revenue_df[col].quantile(0.75)
    iqr = q3 - q1
    lower_bound = q1 - 1.5 * iqr
    upper_bound = q3 + 1.5 * iqr
    revenue_df = revenue_df[(revenue_df[col] >= lower_bound) & (revenue_df[col] <= upper_bound)]

print("Dataset setelah penghapusan outliers:")
print(revenue_df.head().to_markdown())

"""Deskripsi : Menghapus outlier dari kolom numerik menggunakan metode IQR."""

# Boxplot untuk mendeteksi outlier
for col in numeric_columns:
    plt.figure(figsize=(8, 4))
    sns.boxplot(data=revenue_df, y=col, color='orange')
    plt.title(f'Boxplot {col}')
    plt.ylabel(col)
    plt.show()

"""Deskripsi : Membuat ulang boxplot untuk setiap kolom numerik setelah penghapusan outlier. Visualisasi ini memverifikasi bahwa outlier telah dihapus, ditunjukkan dengan tidak adanya titik-titik ekstrem di luar batas boxplot.

## Proses Encoding kategorikal dengan menggunakan metode one-hot encoding menggunakan pd.get_dummies()
"""

# Encoding
categorical_columns = revenue_df.select_dtypes(include=['object']).columns
print("Kolom kategorikal:")
print(categorical_columns.to_list())
# Pilih kolom kategorikal
categorical_columns = revenue_df.select_dtypes(include=['object']).columns
print("Kolom kategorikal setelah penghapusan:")
print(list(categorical_columns))
# Terapkan One-Hot Encoding menggunakan pd.get_dummies()
revenue_df_onehot_encoded = pd.get_dummies(revenue_df, columns=categorical_columns)

print("Data setelah One-Hot Encoding (pd.get_dummies):")
print(revenue_df_onehot_encoded.head().to_markdown())

"""Deskripsi : Mengidentifikasi kolom kategorikal (tipe data object) untuk persiapan encoding. Kemudian mengulang identifikasi kolom kategorikal untuk memastikan konsistensi setelah pembersihan data. Kemudian Menerapkan One-Hot Encoding menggunakan pd.get_dummies() untuk mengubah kolom kategorikal menjadi kolom biner (0 atau 1).

## Menerapkan Feature Engineering proses penambahan fitur revenue
"""

# Hitung revenue per transaksi
revenue_df['revenue'] = revenue_df['transaction_qty'] * revenue_df['unit_price']

# 1. Analisis Revenue Berdasarkan Kategori Produk
revenue_by_category = revenue_df.groupby('product_category')['revenue'].agg(['sum', 'mean', 'count']).reset_index()
revenue_by_category.columns = ['Product_Category', 'Total_Revenue', 'Average_Revenue', 'Transaction_Count']

print("\nRevenue Berdasarkan Kategori Produk:")
print(revenue_by_category.to_markdown(index=False))

"""Deskripsi : Membuat fitur baru revenue dengan mengalikan transaction_qty (jumlah transaksi) dan unit_price (harga satuan). Fitur ini menjadi target utama untuk prediksi dalam model regresi. Kemudian mengelompokkan data berdasarkan product_category untuk menghitung total revenue, rata-rata revenue, dan jumlah transaksi per kategori. Ini memberikan wawasan tentang performa penjualan per kategori produk."""

# Visualisasi Revenue per Kategori
plt.figure(figsize=(12, 6))
sns.barplot(data=revenue_by_category, x='Product_Category', y='Total_Revenue')
plt.xticks(rotation=45)
plt.title('Total Revenue per Kategori Produk')
plt.xlabel('Kategori Produk')
plt.ylabel('Total Revenue')
plt.tight_layout()
plt.show()

"""Deskripsi : Membuat barplot untuk memvisualisasikan total revenue per kategori produk. Grafik ini menunjukkan kategori mana yang menghasilkan pendapatan tertinggi, membantu dalam pengambilan keputusan bisnis."""

# 2. Analisis Perhitungan Revenue Berdasarkan Tipe Produk
revenue_by_type = revenue_df.groupby('product_type')['revenue'].agg(['sum', 'mean', 'count']).reset_index()
revenue_by_type.columns = ['Product_Type', 'Total_Revenue', 'Average_Revenue', 'Transaction_Count']

print("\nRevenue Berdasarkan Tipe Produk:")
print(revenue_by_type.to_markdown(index=False))

"""Deskripsi : Mengelompokkan data berdasarkan product_type untuk menghitung total revenue, rata-rata revenue, dan jumlah transaksi per tipe produk. Analisis ini memberikan detail lebih spesifik dibandingkan kategori produk."""

# Visualisasi Revenue per Tipe
plt.figure(figsize=(12, 6))
sns.barplot(data=revenue_by_type, x='Product_Type', y='Total_Revenue')
plt.xticks(rotation=45)
plt.title('Total Revenue per Tipe Produk')
plt.xlabel('Tipe Produk')
plt.ylabel('Total Revenue')
plt.tight_layout()
plt.show()

"""Deskripsi : Membuat barplot untuk memvisualisasikan total revenue per tipe produk. Grafik ini membantu mengidentifikasi tipe produk yang paling menguntungkan."""

# 3. Analisis Perhitungan Distribusi Revenue Berdasarkan Lokasi
revenue_by_location = revenue_df.groupby('store_location')['revenue'].agg(['sum', 'mean', 'count']).reset_index()
revenue_by_location.columns = ['Store_Location', 'Total_Revenue', 'Average_Revenue', 'Transaction_Count']

print("\nRevenue Berdasarkan Lokasi Toko:")
print(revenue_by_location.to_markdown(index=False))

"""Deskripsi : Mengelompokkan data berdasarkan store_location untuk menghitung total revenue, rata-rata revenue, dan jumlah transaksi per lokasi toko. Ini membantu memahami performa penjualan berdasarkan lokasi geografis."""

# Visualisasi Distribusi Revenue Berdasarkan Lokasi menggunakan Pie Chart
plt.figure(figsize=(10, 8))
plt.pie(revenue_by_location['Total_Revenue'],
        labels=revenue_by_location['Store_Location'],
        autopct='%1.1f%%',
        startangle=90,
        colors=sns.color_palette('pastel'))
plt.title('Distribusi Total Revenue Berdasarkan Lokasi Toko', pad=20)
plt.axis('equal')
plt.show()

"""Deskripsi : Membuat pie chart untuk memvisualisasikan distribusi total revenue berdasarkan lokasi toko. Pie chart menunjukkan proporsi kontribusi setiap lokasi terhadap total pendapatan, membantu dalam analisis distribusi geografis.

python
"""

#  Analisis Growth Revenue
# Konversi transaction_date ke format datetime
revenue_df['transaction_date'] = pd.to_datetime(revenue_df['transaction_date'])

# Ekstrak informasi tanggal (tahun, bulan, minggu, hari)
revenue_df['year'] = revenue_df['transaction_date'].dt.year
revenue_df['month'] = revenue_df['transaction_date'].dt.month
revenue_df['week'] = revenue_df['transaction_date'].dt.isocalendar().week
revenue_df['day'] = revenue_df['transaction_date'].dt.day

"""Deskripsi : Mengonversi kolom transaction_date ke format datetime untuk memungkinkan ekstraksi informasi waktu seperti tahun, bulan, dan hari. Kemudian Mengekstrak fitur baru (year, month, week, day) dari transaction_date."""

# 1. Analisis Growth Revenue Bulanan
monthly_revenue = revenue_df.groupby(['year', 'month'])['revenue'].sum().reset_index()
monthly_revenue['year_month'] = monthly_revenue['year'].astype(str) + '-' + monthly_revenue['month'].astype(str).str.zfill(2)
monthly_revenue['growth'] = monthly_revenue['revenue'].pct_change() * 100

print("\nRevenue Bulanan dan Pertumbuhan:")
print(monthly_revenue[['year_month', 'revenue', 'growth']].to_markdown(index=False))

# Visualisasi Revenue Bulanan
plt.figure(figsize=(12, 6))
sns.lineplot(data=monthly_revenue, x='year_month', y='revenue', marker='o')
plt.xticks(rotation=45)
plt.title('Revenue Bulanan')
plt.xlabel('Tahun-Bulan')
plt.ylabel('Total Revenue')
plt.tight_layout()
plt.show()

"""Deskripsi : Menghitung total revenue per bulan dengan mengelompokkan data berdasarkan year dan month. Membuat kolom year_month untuk label waktu dan menghitung pertumbuhan persentase revenue bulanan menggunakan pct_change(). Kemudian membuat line plot untuk memvisualisasikan revenue bulanan. Grafik ini menunjukkan tren pendapatan dari waktu ke waktu, dengan titik-titik menandakan nilai bulanan, membantu mengidentifikasi pola musiman atau pertumbuhan.

## Proses Standarisasi Fitur numerik
"""

# Definisikan fitur dan target
X = revenue_df.drop(columns=['revenue', 'transaction_date', 'transaction_id', 'transaction_time', 'store_id', 'product_id', 'year', 'month', 'week', 'day'])
y = revenue_df['revenue']

# Pra-pemrosesan untuk model regresi
numeric_features = ['transaction_qty', 'unit_price', 'unit_price_log']
categorical_features = ['store_location', 'product_category', 'product_type', 'product_detail']

preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), numeric_features),
        ('cat', OneHotEncoder(drop='first', sparse_output=False), categorical_features)
    ])

"""Deskripsi : Mendefinisikan fitur (X) dan target (y) untuk modeling. Kemudian mengidentifikasi kolom numerik (transaction_qty, unit_price, unit_price_log) dan kategorikal (store_location, product_category, product_type, product_detail) untuk preprocessing. Pemisahan ini memungkinkan penerapan transformasi yang berbeda pada jenis data yang berbeda. Kemudian membuat ColumnTransformer untuk preprocessing. Fitur numerik distandarisasi menggunakan StandardScaler (mean=0, std=1), sedangkan fitur kategorikal diencode menggunakan OneHotEncoder (dengan drop='first' untuk menghindari multicollinearity). Ini memastikan data siap untuk model regresi.

## Proses Split Data
"""

# Pemisahan data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""Deskripsi : Membagi dataset menjadi data pelatihan (80%) dan pengujian (20%) menggunakan train_test_split.

## Modeling

## Model 1 Elastic Net Regression
"""

# 1. Prediksi Revenue dengan Elastic Net Regression
enet_pipeline = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('regressor', ElasticNet(random_state=42))
])

# Hyperparameter tuning
param_grid_enet = {
    'regressor__alpha': [0.1, 1.0, 10.0],
    'regressor__l1_ratio': [0.1, 0.5, 0.9]
}
grid_search_enet = GridSearchCV(enet_pipeline, param_grid_enet, cv=5, scoring='r2', n_jobs=-1)
grid_search_enet.fit(X_train, y_train)

# Model terbaik
best_enet = grid_search_enet.best_estimator_
y_train_pred_enet = best_enet.predict(X_train)
y_test_pred_enet = best_enet.predict(X_test)

"""Deskripsi : Membuat pipeline untuk model Elastic Net Regression. Pipeline menggabungkan preprocessing (preprocessor) dan model regresi (ElasticNet)."""

# Evaluasi
train_mse_enet = mean_squared_error(y_train, y_train_pred_enet)
test_mse_enet = mean_squared_error(y_test, y_test_pred_enet)
train_r2_enet = r2_score(y_train, y_train_pred_enet)
test_r2_enet = r2_score(y_test, y_test_pred_enet)
cv_scores_enet = cross_val_score(best_enet, X, y, cv=5, scoring='r2')

print("\nHasil Evaluasi Elastic Net Regression:")
print(f"Best Parameters: {grid_search_enet.best_params_}")
print(f"Training MSE: {train_mse_enet:.2f}")
print(f"Testing MSE: {test_mse_enet:.2f}")
print(f"Training R² Score: {train_r2_enet:.4f}")
print(f"Testing R² Score: {test_r2_enet:.4f}")
print(f"Cross-Validation R² Mean: {cv_scores_enet.mean():.4f}")

"""Deskripsi : Mengevaluasi performa model Elastic Net menggunakan Mean Squared Error (MSE) dan R² Score untuk data pelatihan dan pengujian."""

# Visualisasi
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_test_pred_enet, color='green', alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
plt.xlabel('Revenue Aktual')
plt.ylabel('Revenue Prediksi')
plt.title('Prediksi vs Aktual (Elastic Net)')
plt.show()

"""Deskripsi : Membuat scatter plot untuk membandingkan revenue aktual vs prediksi dari model Elastic Net. Garis merah putus-putus menunjukkan prediksi ideal (aktual = prediksi). Grafik ini membantu mengevaluasi seberapa dekat prediksi dengan nilai sebenarnya.

## Model 2 Linear Regression
"""

#  2. Linear Regression
linear_pipeline = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('regressor', LinearRegression())
])

# Latih model Linear Regression
linear_pipeline.fit(X_train, y_train)

# Prediksi
y_train_pred_linear = linear_pipeline.predict(X_train)
y_test_pred_linear = linear_pipeline.predict(X_test)

"""Deskripsi : Membuat pipeline untuk model Linear Regression. Pipeline menggabungkan preprocessing (preprocessor) dan model regresi (LinearRegression)."""

# Evaluasi
train_mse_linear = mean_squared_error(y_train, y_train_pred_linear)
test_mse_linear = mean_squared_error(y_test, y_test_pred_linear)
train_r2_linear = r2_score(y_train, y_train_pred_linear)
test_r2_linear = r2_score(y_test, y_test_pred_linear)

print("\nHasil Evaluasi Linear Regression:")
print(f"Training MSE: {train_mse_linear:.2f}")
print(f"Testing MSE: {test_mse_linear:.2f}")
print(f"Training R² Score: {train_r2_linear:.4f}")
print(f"Testing R² Score: {test_r2_linear:.4f}")

"""Deskripsi : Mengevaluasi performa model Linear Regression menggunakan MSE dan R² Score untuk data pelatihan dan pengujian. Ini mengukur akurasi prediksi dan kecocokan model."""

# Visualisasi
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_test_pred_linear, color='blue', alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
plt.xlabel('Revenue Aktual')
plt.ylabel('Revenue Prediksi')
plt.title('Prediksi vs Aktual (Linear Regression)')
plt.show()

"""Deskripsi : Membuat scatter plot untuk membandingkan revenue aktual vs prediksi dari model Linear Regression."""

# --- Perbandingan Performa Model ---
print("\nPerbandingan Performa Model:")
print("Elastic Net Regression (Prediksi Revenue):")
print(f"Training MSE: {train_mse_enet:.2f}, Testing MSE: {test_mse_enet:.2f}")
print(f"Training R²: {train_r2_enet:.4f}, Testing R²: {test_r2_enet:.4f}")
print("Linear Regression (Prediksi Revenue):")
print(f"Training MSE: {train_mse_linear:.2f}, Testing MSE: {test_mse_linear:.2f}")
print(f"Training R²: {train_r2_linear:.4f}, Testing R²: {test_r2_linear:.4f}")

"""Deskripsi : Menampilkan perbandingan performa antara Elastic Net dan Linear Regression berdasarkan MSE dan R² untuk pelatihan dan pengujian. Ini membantu menentukan model mana yang lebih baik untuk memprediksi revenue."""